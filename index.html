<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.js"></script>
<html>
    <head>
        <style>
            h1 {
                text-align: center;
            }
            #scene1,#scene2,#scene3 {
              /* margin-left: 300px; */
              display:flex;
              justify-content: center;
              align-items: center;
            }
            /* .selected {
              opacity: 1 !important;
              stroke: black;
              stroke-width: 1px;
              fill:'#00ffff'
            } */
        </style>
        <title>Martini Glass Narraive Visualization for sales performance report</title>
    </head>
    <body>

        <div><h1>scene 1 scatter plot of city mpg and highway mpg for each model</h1></div>
        <div id="scene1"></div>

        <div><h1>scene 2 ranking of city mpg and highway mpg within each power</h1></div>
        <p>please select one fuel: </p>
          <input type="radio"  name="fuel" value="Gasoline" checked="True">
          <label >Gasoline</label><br>
          <input type="radio"  name="fuel" value="Electricity">
          <label >Electricity</label><br>
          <input type="radio"  name="fuel" value="Diesel">
          <label >Diesel</label><br>
        <p>please select one number of cylinder: </p>
          <input type="radio"  name="cylinder" value="2">
          <label >2</label><br>
          <input type="radio"  name="cylinder" value="4">
          <label >4</label><br>
          <input type="radio"  name="cylinder" value="6" checked="True">
          <label >6</label><br>
          <input type="radio"  name="cylinder" value="8">
          <label >8</label><br>
        <!-- <label>enter fuel: </label><input id="fuel"><br><br>
        <label>enter number of cylinder: </label><input id="number_cylinder"><br><br> -->
        <button onclick="update_scene2(get_selected('fuel'),get_selected('cylinder'))">find</button>
        <div id="scene2"></div>

        <div><h1>scene 3 proportion of each power of each maker</h1></div>
        <div id="scene3"></div>
          <p>please select maker:</p>
          <input type="radio"  name="maker" value="All" checked="True">
          <label >All</label><br>
          <input type="radio"  name="maker" value="Mitsubishi">
          <label >Mitsubishi</label><br>
          <input type="radio"  name="maker" value="BMW">
          <label >BMW</label><br>
          <input type="radio"  name="maker" value="Hyundai">
          <label >Hyundai</label><br>
        <br>
        <button onclick="update_scene3(get_selected('maker'))">find</button>
    </body>
</html>
<script>

//scene1
function update_scene1(){
  var margin = {top: 10, right: 30, bottom: 30, left: 60},
    width = 800 - margin.left - margin.right,
    height = 800 - margin.top - margin.bottom;

  // append the svg object to the body of the page
  var svg = d3.select("#scene1")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
  d3.csv("https://flunky.github.io/cars2017.csv", function(data) {

    var tooltip_1 = d3.select("#scene1")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "1px")
    .style("border-radius", "5px")
    .style("padding", "2px")
    .style('position','absolute');
  var mouseover_1 = function(d) {
    tooltip_1
      .style("opacity", 1)
  }

  var mousemove_1 = function(d) {
    tooltip_1
      .html("average city mpg: " + d.AverageCityMPG + '</br>average highway mpg: ' + d.AverageHighwayMPG + '</br>make: ' + d.Make + '</br>fuel: ' + d.Fuel + '</br>number cylinder: ' 
        +d.EngineCylinders
      )
      .style("left", (d3.mouse(this)[0])  + 400 + "px") // It is important to put the +90: other wise the tooltip is exactly where the point is an it creates a weird effect
      .style("top", + (d3.mouse(this)[1]) -50 +  "px");
    console.log(d3.mouse(this));
  }

  // A function that change this tooltip when the leaves a point: just need to set opacity to 0 again
  var mouseleave_1 = function(d) {
    tooltip_1
      .transition()
      .duration(200)
      .style("opacity", 0)
  }
  // Add X axis
  var x = d3.scaleLog().domain([10,150]).range([0,width]).base(10);
  // var x = d3.scaleLinear()
  //   .domain([0, 160])
  //   .range([ 0, width ]);
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x).tickValues([10,20,50,100]).tickFormat(d3.format(".0f")));

  // Add Y axis
  var y = d3.scaleLog().domain([10,150]).range([height,0]).base(10);
  // var y = d3.scaleLinear()
  //   .domain([0, 160])
  //   .range([ height, 0]);
  svg.append("g")
    .call(d3.axisLeft(y).tickValues([10,20,50,100]).tickFormat(d3.format(".0f")));

  // Add dots
  var dot = svg.append('g')
    .selectAll("dot")
    .data(data)
    .enter()
    .append("circle")
      .attr("cx", function (d) { return x(d.AverageHighwayMPG); } )
      .attr("cy", function (d) { return y(d.AverageCityMPG); } )
      .attr("r", 4)
      .style("fill", "#0000ff");
    d3.selectAll('circle')
      .on('mouseover',mouseover_1)
      .on('mousemove',mousemove_1)
      .on('mouseleave',mouseleave_1);
  // Add brushing
  // svg
  //   .call( d3.brush()                 // Add the brush feature using the d3.brush function
  //     .extent( [ [0,0], [width,height] ] ) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
  //     .on("start brush", updateChart) // Each time the brush selection changes, trigger the 'updateChart' function
  //   )

  // // Function that is triggered when brushing is performed
  // function updateChart() {
  //   extent = d3.event.selection
  //   dot.classed("selected", function(d){ return isBrushed(extent, x(d.Sepal_Length), y(d.Petal_Length) ) } )
  // }

  // // A function that return TRUE or FALSE according if a dot is in the selection or not
  // function isBrushed(brush_coords, cx, cy) {
  //      var x0 = brush_coords[0][0],
  //          x1 = brush_coords[1][0],
  //          y0 = brush_coords[0][1],
  //          y1 = brush_coords[1][1];
  //     return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;    // This return TRUE or FALSE depending on if the points is in the selected area
  // }


})
}

update_scene1()




// //scene2
// var margin = {top: 30, right: 30, bottom: 70, left: 60},
//     width = 2000 - margin.left - margin.right,
//     height = 600 - margin.top - margin.bottom;

// // append the svg object to the body of the page
// var svg = d3.select("#scene2")
//   .append("svg")
//     .attr("width", width + margin.left + margin.right)
//     .attr("height", height + margin.top + margin.bottom)
//   .append("g")
//     .attr("transform",
//           "translate(" + margin.left + "," + margin.top + ")");



// A function that create / update the plot for a given variable:
function update_scene2(fuel,number_cylinder) {
  d3.select('#scene2').html('')
  // console.log(fuel + number_cylinder)
  //scene2
  var margin = {top: 30, right: 30, bottom: 70, left: 60},
      width = 1600 - margin.left - margin.right,
      height = 600 - margin.top - margin.bottom;

  // append the svg object to the body of the page
  var svg = d3.select("#scene2")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
  d3.csv("https://flunky.github.io/cars2017.csv", function(data) {
    var filtered_data=data.filter(function(d){return (d.Fuel==fuel && d.EngineCylinders==number_cylinder)})
    // console.log(filtered_data)
    if (filtered_data.length==0){
      alert('can not find data that match filter. please choose another pair')
      return
    }
    filtered_data.sort(function(b,a){return a.AverageCityMPG-b.AverageCityMPG;});
    // X axis
    var x = d3.scaleBand()
      .range([ 0, width ])
      .domain(filtered_data.map(function(d) { return d.Make; }))
      .padding(0.2);
    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));
    var candidate=filtered_data.map(object=>object.AverageCityMPG)
    var max_value=Math.max(...candidate)
    // Add Y axis
    var y = d3.scaleLinear()
      .domain([0, max_value])
      .range([ height, 0]);
    svg.append("g")
      .attr("class", "myYaxis")
      .call(d3.axisLeft(y));
  var tooltip = d3.select("#scene2")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "1px")
    .style("border-radius", "5px")
    .style("padding", "2px")
    .style('position','absolute')
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
  }

  var mousemove = function(d) {
    tooltip
      .html("average city mpg: " + d.AverageCityMPG + ' make: ' + d.Make)
      .style("left", (d3.mouse(this)[0])  + "px") // It is important to put the +90: other wise the tooltip is exactly where the point is an it creates a weird effect
      .style("top",  (d3.mouse(this)[1]) + 1100+ "px");
    console.log(d3.mouse(this));
  }

  // A function that change this tooltip when the leaves a point: just need to set opacity to 0 again
  var mouseleave = function(d) {
    tooltip
      .transition()
      .duration(200)
      .style("opacity", 0)
  }
  var u = svg.selectAll("rect")
    .data(filtered_data)
  
  u
    .enter()
    .append("rect")
    .merge(u)
    .transition()
    .duration(1000)
      .attr("x", function(d) { return x(d.Make); })
      .attr("y", function(d) { return y(d.AverageCityMPG); })
      .attr("width", x.bandwidth())
      .attr("height", function(d) { return height - y(d.AverageCityMPG); })
      .attr("fill", "#69b3a2")
  d3.selectAll('rect')
    .on('mouseover',mouseover)
    .on('mousemove',mousemove)
    .on('mouseleave',mouseleave)
  })

}
update_scene2('Gasoline','6')



// scene3
// set the dimensions and margins of the graph
var width = 450
    height = 450
    margin = 40

// The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
var radius = Math.min(width, height) / 2 - margin

// append the svg object
var svg = d3.select("#scene3")
  .append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

function update_scene3(maker){
  if (maker==null){
    alert('please select a power')
    return
  }
  d3.select('#scene3').html('')
  var width = 600
    height = 600
    margin = 40

  // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
  var radius = Math.min(width, height) / 2 - margin

  // append the svg object
  var svg = d3.select("#scene3")
    .append("svg")
      .attr("width", width)
      .attr("height", height)
    .append("g")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
  d3.csv("https://flunky.github.io/cars2017.csv", function(data) {
    var filtered_data={}
    if (maker=='All'){
      filtered_data=data
    }
    else {
      filtered_data=data.filter(function(d){return (d.Make==maker)})
    }
    var dict={'Gasoline':0,'Electricity':0,'Diesel':0};
    for (var obj of filtered_data) {
      dict[obj.Fuel]+=1
    }
    // console.log(dict);
    // set the color scale
    var color = d3.scaleOrdinal()
      .domain(dict)
      .range(["#0000ff", "#ff0000", "#ffff00"])

    // Compute the position of each group on the pie:
    var pie = d3.pie()
      .value(function(d) {return d.value; })
    var data_ready = pie(d3.entries(dict))
    var arcGenerator = d3.arc()
    .innerRadius(0)
    .outerRadius(radius)

    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svg
      .selectAll('whatever')
      .data(data_ready)
      .enter()
      .append('path')
      .attr('d', d3.arc()
        .innerRadius(0)
        .outerRadius(radius)
      )
      .attr('fill', function(d){ return(color(d.data.key)) })
      .attr("stroke", "black")
      .style("stroke-width", "2px")
      .style("opacity", 0.7)
    // add annotation
    svg
    .selectAll('mySlices')
    .data(data_ready)
    .enter()
    .append('text')
    .text(function(d){ return  d.data.key + ' ' + (dict[d.data.key]/filtered_data.length*100).toFixed(2)+'%'})
    .attr("transform", function(d) { return "translate(" + arcGenerator.centroid(d) + ")";  })
    .style("text-anchor", "middle")
    .style("font-size", 12)
  })
}
function get_selected(name){
  var elements = document.getElementsByName(name)
  for (i=0;i<elements.length;i++){
    if (elements[i].checked){
      console.log(elements[i].value)
      return elements[i].value
    }
  }
  return null
}

update_scene3('All')

</script>